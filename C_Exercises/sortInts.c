#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int stringToInt(char*array[]);
void bubbleSort(int * array, int size);
void merge(int * array, int l, int m, int r);
void mergeSort(int * array, int l, int r);
int hoarePartition(int * array, int l, int r);
void quickSort(int * array, int l, int r);
void siftDown(int * array, int low, int high);
void maxHeapify(int * array, int size);
void minHeapSort(int * array, int size);


int main(int argc, char *argv[]){

	if (argc == 2){
                printf("The argument supplied is %s\n", argv[1]);
        }
        else if (argc > 2){
                printf("You have supplied too many arguments; only one is expected.\n");
        }
        else{
                printf("One argument is expected.\n");
        }

	int intFromString = stringToInt(argv);

	int arrayOfIntsA[20] = {5, 7, 9, 13, 19, 1, 4, 3, 0, 18, 2, 8, 12, 6, 10, 17, 15, 11, 16, 14};
	int arrayOfIntsB[20] = {5, 7, 9, 13, 19, 1, 4, 3, 0, 18, 2, 8, 12, 6, 10, 17, 15, 11, 16, 14};
	int arrayOfIntsC[20] = {5, 7, 9, 13, 19, 1, 4, 3, 0, 18, 2, 8, 12, 6, 10, 17, 15, 11, 16, 14};
	int arrayOfIntsD[20] = {5, 7, 9, 13, 19, 1, 4, 3, 0, 18, 2, 8, 12, 6, 10, 17, 15, 11, 16, 14};

	int numElements = 20;
	
	printf("The following arrays are hard coded.\n");
	printf("The Array before Bubble sorting is as follows:\n");
	for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsA[i]);
        }

	bubbleSort(arrayOfIntsA, numElements);
	printf("The Array after Bubble Sort is as follows:\n");
	for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsA[i]);
        }

	printf("The Array before Merge sorting is as follows:\n");
        for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsB[i]);
        }


	mergeSort(arrayOfIntsB, 0, (numElements-1));
	printf("The Array after Merge Sort is as follows:\n");
	for (int j = 0; j < numElements; j++){
                printf("\t%d\n", arrayOfIntsB[j]);
        }


	printf("The Array before Quick sorting is as follows:\n");
        for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsC[i]);
        }
	quickSort(arrayOfIntsC, 0, numElements-1);
	printf("The Array after Quick sorting is as follows:\n");
        for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsC[i]);
        }


	printf("The Array before Heap sorting is as follows:\n");
        for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsD[i]);
        }

	minHeapSort(arrayOfIntsD, numElements);

	printf("The Array after Heap sorting is as follows:\n");
        for (int i = 0; i < numElements; i++){
                printf("\t%d\n", arrayOfIntsD[i]);
        }

	int arraySize = intFromString * sizeof(int);

	int * randomArrayA = malloc(arraySize);
	for(int i = 0; i < intFromString; i++){
		randomArrayA[i] = (rand()%2147483647);
	}

	int * randomArrayB = malloc(arraySize);
	for(int i = 0; i < intFromString; i++){
                randomArrayB[i] = (rand()%2147483647);
        }

	int * randomArrayC = malloc(arraySize);
	for(int i = 0; i < intFromString; i++){
                randomArrayC[i] = (rand()%2147483647);
        }

	int * randomArrayD = malloc(arraySize);
	for(int i = 0; i < intFromString; i++){
                randomArrayD[i] = (rand()%2147483647);
        }


	printf("The following arrays are randomly generated by user input.");
	printf("The Array before Bubble sorting is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayA[i]);
        }

        bubbleSort(randomArrayA, intFromString);

        printf("The Array after Bubble Sort is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayA[i]);
        }

        printf("The Array before Merge sorting is as follows:\n");

        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayB[i]);
        }


        mergeSort(randomArrayB, 0, (intFromString-1));

        printf("The Array after Merge Sort is as follows:\n");
        for (int j = 0; j < intFromString; j++){
                printf("\t%d\n", randomArrayB[j]);
        }


        printf("The Array before Quick sorting is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayC[i]);
        }
        quickSort(randomArrayC, 0, intFromString-1);

        printf("The Array after Quick sorting is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayC[i]);
        }


        printf("The Array before Heap sorting is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayD[i]);
        }

        minHeapSort(randomArrayD, intFromString);

        printf("The Array after Heap sorting is as follows:\n");
        for (int i = 0; i < intFromString; i++){
                printf("\t%d\n", randomArrayD[i]);
	}

	free(randomArrayA);
	free(randomArrayB);
	free(randomArrayC);
	free(randomArrayD);

}


void bubbleSort(int array[], int size){

	/*********************************************************************************************
	/ 1. Keeps track of if the array is swapped.                                                 /
	/ 2. Starts at array[1] and checks to see if the the previous value is larger.               /
	/	-- if its bigger, swaps the two values.                                              /
	/ 3. If values get swapped, the tracker remains 1; else it is zero and the array is ordered. /
	*********************************************************************************************/
	int recursed = 1;
	int swapped = 1;

	for(int pass = 0; pass<size; pass++){
		for (int i = 1; i < size; i++){
			if(array[i-1] > array[i]){
				int temp = array[i];
				array[i] = array[i-1];
				array[i-1] = temp;
			}
		} 
	}

	return;
}

void  merge(int * array, int l, int m, int r){

	/***********************************************************************************
	/ 1. Checks to see if the left side value is smaller than the right side value.    /
	/	-- if true, places left side value in temp array                           /
	/	-- else, places right side value in temp array                             /
	/ 2. Places leftover left and right values into the temp array.                    /
	/ 3. Places temp array, now ordered, into original array.                          /
	/ 4. Returns to mergeSort.                                                         /
	***********************************************************************************/

	int low1, low2, i;

	int tempArray[(r+1)];

	for(low1 = l, low2 = m+1, i = l; low1<=m && low2<=r; i++){
		if(array[low1]<=array[low2]){
			//insert a[low1] into tempArray
			//low1++
			tempArray[i] = array[low1];
			low1++;
		}
		else{
			//insert a[low2] into tempArray
			//low2++
			tempArray[i] = array[low2];
			low2++;
		}
	}

	while(low1 <= m){
		//insert remaining a[low1] into tempArray[i]
		//low1++, i++
		tempArray[i] = array[low1];
		low1++;
		i++;
	}

	while(low2<=r){
		//insert remaining a[low2] into tempArray[i]
		//low2++, i++
		tempArray[i] = array[low2];
		low2++;
		i++;
	}

	for(i = l; i <= r; i++){
		//put tempArray into a in correct order.
		array[i] = tempArray[i];
	}
}

void mergeSort(int * array, int l, int r){

	/*********************************************************************
	/ 1. Checks to see if the size of the array is larger than 1.        /
	/	-- if not larger than one, returns                           /
	/ 2. If size > 1, divides array in half recursively until size is 1. /
	/ 3. Once size is one, sorts and merges array using merge().         /
	*********************************************************************/

	if(l < r){
		int m = (l+r)/2;

		mergeSort(array, l, m);
		mergeSort(array, m+1, r);

		merge(array, l, m, r);

	}
	else{
		return;
	}
}

int hoarePartition(int * array, int l, int r){

	/*********************************************************************************************
	/ 1. Makes a pivot element out of the first element.					     /
	/ 2. Start from low and high ends and checks to see if each element is less/more than pivot. /
	/	-- will swap elements								     /
	/ 3. If the tracker for the beginning is >= to the end tracker, returns to quickSort().      /
	*********************************************************************************************/
	
	int pivot = array[l];
	int i = l-1;
	int j = r+1;
	
	int tracker = 1;

	while(tracker){
		do{
			i = i+1;
		} while(array[i] < pivot);

		do{
			j = j-1;
		} while(array[j] > pivot);

		if (i >= j){
			return j;
		}
		else{
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}
}

void quickSort(int * array, int l, int r){

	/***********************************************************************************************
	/ 1. If size of array is larger than 1, splits array based on partition using hoarePartition() /
	/ 2. Else, returns.									       /
	***********************************************************************************************/
	
	if(l<r){
		int partition = hoarePartition(array, l, r);
		quickSort(array, l, partition);
		quickSort(array, (partition+1), r);
	}
}

void siftDown(int * array, int size, int index){
	
	/******************************************************************************
        / 1. Finds index of left and right children.                                  /
        / 2. Tests left and right children to root.                                   /
        / 3. if l or r are smaller than the root, swap.                               /
        / 4. Recursively call siftDown to ensure swapped element is larger than root. /
        ******************************************************************************/
	
	int largest = 0;
	int lChild = (index*2)+1;
	int rChild = (index*2)+2;

	if (lChild<size){
		if (array[lChild] > array[largest]){
			largest = lChild;
		}
	}

	if (rChild<size){
		if (array[rChild] > array[largest]){
			largest = rChild;
		}
	}
	if (largest != 0){
		int temp = array[0];
		array[0] = array[largest];
		array[largest] = temp;

		siftDown(array, size, largest);
	}
}

void maxHeapify(int * array, int size){

	/**********************************************
	/ 1. Calls sift down on each element of array /
	**********************************************/

	for (int i = size; i >= 0; i--){
		siftDown(array, size, i);
	}
}

void minHeapSort(int * array, int size){
	
	/**********************************************************************************************
	/ 1. Calls maxHeapify on every element of array.                                              /
	/ 2. Swaps first element with last element.                                                   /
	/ 3. Calls maxHeapify on every element again to ensure correct maxHeap.                       /
	/ 4. Reduces size of array by one in order to place largest element in the back of the array. /
	**********************************************************************************************/	

	for (int i = (size-1); i >=0; i--){
		maxHeapify(array, i);
		int temp = array[0];
		array[0] = array[i];
		array[i] = temp;
		maxHeapify(array, i);
	}
}

int stringToInt(char*array[]){
	int intFromString = 0;
	int len = strlen(array[1]);

	for (int i = 0; i<len; i++){
		intFromString = (intFromString * 10) + (array[1][i] - '0');
	}
	return intFromString;
}














